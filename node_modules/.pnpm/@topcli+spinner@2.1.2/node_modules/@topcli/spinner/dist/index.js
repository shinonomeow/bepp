var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/Spinner.class.ts
import { EventEmitter } from "events";
import { performance } from "perf_hooks";
import readline from "readline";
import cliSpinners from "cli-spinners";
import stripAnsi from "strip-ansi";
import ansiRegex from "ansi-regex";
import wcwidth from "@topcli/wcwidth";
import kleur from "kleur";
var internalSpinnerCount = 0;
var kDefaultSpinnerName = "dots";
var kLogSymbols = process.platform !== "win32" || process.env.CI || process.env.TERM === "xterm-256color" ? { success: kleur.bold().green("\u2714"), error: kleur.bold().red("\u2716") } : { success: kleur.bold().green("\u221A"), error: kleur.bold().red("\xD7") };
var _verbose, _started, _spinner, _text, _prefix, _color, _interval, _frameIndex, _spinnerPos, _startTime, _getSpinnerFrame, getSpinnerFrame_fn, _lineToRender, lineToRender_fn, _renderLine, renderLine_fn, _stop, stop_fn;
var Spinner = class extends EventEmitter {
  constructor(options = {}) {
    super();
    __privateAdd(this, _getSpinnerFrame);
    __privateAdd(this, _lineToRender);
    __privateAdd(this, _renderLine);
    __privateAdd(this, _stop);
    this.stream = process.stdout;
    __privateAdd(this, _verbose, true);
    __privateAdd(this, _started, false);
    __privateAdd(this, _spinner, void 0);
    __privateAdd(this, _text, "");
    __privateAdd(this, _prefix, "");
    __privateAdd(this, _color, void 0);
    __privateAdd(this, _interval, null);
    __privateAdd(this, _frameIndex, 0);
    __privateAdd(this, _spinnerPos, 0);
    __privateAdd(this, _startTime, void 0);
    __privateSet(this, _verbose, options.verbose ?? true);
    if (!__privateGet(this, _verbose)) {
      return;
    }
    const { name = kDefaultSpinnerName, color = null } = options;
    __privateSet(this, _spinner, name in cliSpinners ? cliSpinners[name] : cliSpinners[kDefaultSpinnerName]);
    if (color === null) {
      __privateSet(this, _color, (str) => str);
    } else {
      __privateSet(this, _color, color in kleur ? kleur[color] : kleur.white);
    }
  }
  static reset() {
    internalSpinnerCount = 0;
  }
  get started() {
    return __privateGet(this, _started);
  }
  get verbose() {
    return __privateGet(this, _verbose);
  }
  get elapsedTime() {
    return performance.now() - __privateGet(this, _startTime);
  }
  get startTime() {
    return __privateGet(this, _startTime);
  }
  set text(value) {
    if (typeof value == "string") {
      __privateSet(this, _text, value.replaceAll(/\r?\n|\r/gm, ""));
    }
  }
  get text() {
    return __privateGet(this, _text);
  }
  start(text, options = {}) {
    __privateSet(this, _started, true);
    this.text = text;
    if (typeof options.withPrefix === "string") {
      __privateSet(this, _prefix, options.withPrefix);
    }
    this.emit("start");
    __privateSet(this, _spinnerPos, internalSpinnerCount++);
    __privateSet(this, _startTime, performance.now());
    if (!__privateGet(this, _verbose)) {
      return this;
    }
    __privateSet(this, _frameIndex, 0);
    this.stream.write(__privateMethod(this, _lineToRender, lineToRender_fn).call(this) + "\n");
    __privateSet(this, _interval, setInterval(
      () => __privateMethod(this, _renderLine, renderLine_fn).call(this),
      __privateGet(this, _spinner).interval
    ));
    return this;
  }
  succeed(text) {
    if (__privateGet(this, _started)) {
      __privateMethod(this, _stop, stop_fn).call(this, text);
      __privateMethod(this, _renderLine, renderLine_fn).call(this, kLogSymbols.success);
      this.emit("succeed");
    }
    return this;
  }
  failed(text) {
    if (__privateGet(this, _started)) {
      __privateMethod(this, _stop, stop_fn).call(this, text);
      __privateMethod(this, _renderLine, renderLine_fn).call(this, kLogSymbols.error);
      this.emit("failed");
    }
    return this;
  }
};
_verbose = new WeakMap();
_started = new WeakMap();
_spinner = new WeakMap();
_text = new WeakMap();
_prefix = new WeakMap();
_color = new WeakMap();
_interval = new WeakMap();
_frameIndex = new WeakMap();
_spinnerPos = new WeakMap();
_startTime = new WeakMap();
_getSpinnerFrame = new WeakSet();
getSpinnerFrame_fn = function(spinnerSymbol) {
  if (typeof spinnerSymbol === "string") {
    return spinnerSymbol;
  }
  const { frames } = __privateGet(this, _spinner);
  const frame = frames[__privateGet(this, _frameIndex)];
  __privateSet(this, _frameIndex, ++__privateWrapper(this, _frameIndex)._ < frames.length ? __privateGet(this, _frameIndex) : 0);
  return __privateGet(this, _color).call(this, frame);
};
_lineToRender = new WeakSet();
lineToRender_fn = function(spinnerSymbol) {
  const terminalCol = this.stream.columns;
  const defaultRaw = `${__privateMethod(this, _getSpinnerFrame, getSpinnerFrame_fn).call(this, spinnerSymbol)} ${__privateGet(this, _prefix)}${this.text}`;
  let regexArray = [];
  let count = 0;
  while (1) {
    regexArray = defaultRaw.slice(0, terminalCol + count).match(ansiRegex()) ?? [];
    if (regexArray.length === count) {
      break;
    }
    count = regexArray.length;
  }
  count += regexArray.reduce((prev, curr) => prev + wcwidth(curr), 0);
  return wcwidth(stripAnsi(defaultRaw)) > terminalCol ? `${defaultRaw.slice(0, terminalCol + count)}\x1B[0m` : defaultRaw;
};
_renderLine = new WeakSet();
renderLine_fn = function(spinnerSymbol) {
  if (!__privateGet(this, _verbose)) {
    return;
  }
  const moveCursorPos = internalSpinnerCount - __privateGet(this, _spinnerPos);
  readline.moveCursor(this.stream, 0, -moveCursorPos);
  const line = __privateMethod(this, _lineToRender, lineToRender_fn).call(this, spinnerSymbol);
  readline.clearLine(this.stream, 0);
  this.stream.write(line);
  readline.moveCursor(this.stream, -wcwidth(line), moveCursorPos);
};
_stop = new WeakSet();
stop_fn = function(text) {
  this.text = text;
  __privateSet(this, _started, false);
  if (__privateGet(this, _interval) !== null) {
    clearInterval(__privateGet(this, _interval));
  }
};

// src/computeWithSpinner.ts
var kDefaultSafeLogger = () => void 0;
async function computeWithSpinner(asynchronousOp, options, logs = {}) {
  const { success = kDefaultSafeLogger, fail = kDefaultSafeLogger } = logs;
  const spinner = new Spinner(options.spinner).start(options.text, { withPrefix: options.withPrefix });
  try {
    const response = await asynchronousOp(spinner);
    spinner.succeed(success(spinner.elapsedTime));
    return response;
  } catch (err) {
    spinner.failed(fail(err));
    throw err;
  }
}
export {
  Spinner,
  computeWithSpinner
};
