var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Spinner: () => Spinner,
  computeWithSpinner: () => computeWithSpinner
});
module.exports = __toCommonJS(src_exports);

// src/Spinner.class.ts
var import_node_events = require("events");
var import_node_perf_hooks = require("perf_hooks");
var import_node_readline = __toESM(require("readline"), 1);
var import_cli_spinners = __toESM(require("cli-spinners"), 1);
var import_strip_ansi = __toESM(require("strip-ansi"), 1);
var import_ansi_regex = __toESM(require("ansi-regex"), 1);
var import_wcwidth = __toESM(require("@topcli/wcwidth"), 1);
var import_kleur = __toESM(require("kleur"), 1);
var internalSpinnerCount = 0;
var kDefaultSpinnerName = "dots";
var kLogSymbols = process.platform !== "win32" || process.env.CI || process.env.TERM === "xterm-256color" ? { success: import_kleur.default.bold().green("\u2714"), error: import_kleur.default.bold().red("\u2716") } : { success: import_kleur.default.bold().green("\u221A"), error: import_kleur.default.bold().red("\xD7") };
var _verbose, _started, _spinner, _text, _prefix, _color, _interval, _frameIndex, _spinnerPos, _startTime, _getSpinnerFrame, getSpinnerFrame_fn, _lineToRender, lineToRender_fn, _renderLine, renderLine_fn, _stop, stop_fn;
var Spinner = class extends import_node_events.EventEmitter {
  constructor(options = {}) {
    super();
    __privateAdd(this, _getSpinnerFrame);
    __privateAdd(this, _lineToRender);
    __privateAdd(this, _renderLine);
    __privateAdd(this, _stop);
    this.stream = process.stdout;
    __privateAdd(this, _verbose, true);
    __privateAdd(this, _started, false);
    __privateAdd(this, _spinner, void 0);
    __privateAdd(this, _text, "");
    __privateAdd(this, _prefix, "");
    __privateAdd(this, _color, void 0);
    __privateAdd(this, _interval, null);
    __privateAdd(this, _frameIndex, 0);
    __privateAdd(this, _spinnerPos, 0);
    __privateAdd(this, _startTime, void 0);
    __privateSet(this, _verbose, options.verbose ?? true);
    if (!__privateGet(this, _verbose)) {
      return;
    }
    const { name = kDefaultSpinnerName, color = null } = options;
    __privateSet(this, _spinner, name in import_cli_spinners.default ? import_cli_spinners.default[name] : import_cli_spinners.default[kDefaultSpinnerName]);
    if (color === null) {
      __privateSet(this, _color, (str) => str);
    } else {
      __privateSet(this, _color, color in import_kleur.default ? import_kleur.default[color] : import_kleur.default.white);
    }
  }
  static reset() {
    internalSpinnerCount = 0;
  }
  get started() {
    return __privateGet(this, _started);
  }
  get verbose() {
    return __privateGet(this, _verbose);
  }
  get elapsedTime() {
    return import_node_perf_hooks.performance.now() - __privateGet(this, _startTime);
  }
  get startTime() {
    return __privateGet(this, _startTime);
  }
  set text(value) {
    if (typeof value == "string") {
      __privateSet(this, _text, value.replaceAll(/\r?\n|\r/gm, ""));
    }
  }
  get text() {
    return __privateGet(this, _text);
  }
  start(text, options = {}) {
    __privateSet(this, _started, true);
    this.text = text;
    if (typeof options.withPrefix === "string") {
      __privateSet(this, _prefix, options.withPrefix);
    }
    this.emit("start");
    __privateSet(this, _spinnerPos, internalSpinnerCount++);
    __privateSet(this, _startTime, import_node_perf_hooks.performance.now());
    if (!__privateGet(this, _verbose)) {
      return this;
    }
    __privateSet(this, _frameIndex, 0);
    this.stream.write(__privateMethod(this, _lineToRender, lineToRender_fn).call(this) + "\n");
    __privateSet(this, _interval, setInterval(
      () => __privateMethod(this, _renderLine, renderLine_fn).call(this),
      __privateGet(this, _spinner).interval
    ));
    return this;
  }
  succeed(text) {
    if (__privateGet(this, _started)) {
      __privateMethod(this, _stop, stop_fn).call(this, text);
      __privateMethod(this, _renderLine, renderLine_fn).call(this, kLogSymbols.success);
      this.emit("succeed");
    }
    return this;
  }
  failed(text) {
    if (__privateGet(this, _started)) {
      __privateMethod(this, _stop, stop_fn).call(this, text);
      __privateMethod(this, _renderLine, renderLine_fn).call(this, kLogSymbols.error);
      this.emit("failed");
    }
    return this;
  }
};
_verbose = new WeakMap();
_started = new WeakMap();
_spinner = new WeakMap();
_text = new WeakMap();
_prefix = new WeakMap();
_color = new WeakMap();
_interval = new WeakMap();
_frameIndex = new WeakMap();
_spinnerPos = new WeakMap();
_startTime = new WeakMap();
_getSpinnerFrame = new WeakSet();
getSpinnerFrame_fn = function(spinnerSymbol) {
  if (typeof spinnerSymbol === "string") {
    return spinnerSymbol;
  }
  const { frames } = __privateGet(this, _spinner);
  const frame = frames[__privateGet(this, _frameIndex)];
  __privateSet(this, _frameIndex, ++__privateWrapper(this, _frameIndex)._ < frames.length ? __privateGet(this, _frameIndex) : 0);
  return __privateGet(this, _color).call(this, frame);
};
_lineToRender = new WeakSet();
lineToRender_fn = function(spinnerSymbol) {
  const terminalCol = this.stream.columns;
  const defaultRaw = `${__privateMethod(this, _getSpinnerFrame, getSpinnerFrame_fn).call(this, spinnerSymbol)} ${__privateGet(this, _prefix)}${this.text}`;
  let regexArray = [];
  let count = 0;
  while (1) {
    regexArray = defaultRaw.slice(0, terminalCol + count).match((0, import_ansi_regex.default)()) ?? [];
    if (regexArray.length === count) {
      break;
    }
    count = regexArray.length;
  }
  count += regexArray.reduce((prev, curr) => prev + (0, import_wcwidth.default)(curr), 0);
  return (0, import_wcwidth.default)((0, import_strip_ansi.default)(defaultRaw)) > terminalCol ? `${defaultRaw.slice(0, terminalCol + count)}\x1B[0m` : defaultRaw;
};
_renderLine = new WeakSet();
renderLine_fn = function(spinnerSymbol) {
  if (!__privateGet(this, _verbose)) {
    return;
  }
  const moveCursorPos = internalSpinnerCount - __privateGet(this, _spinnerPos);
  import_node_readline.default.moveCursor(this.stream, 0, -moveCursorPos);
  const line = __privateMethod(this, _lineToRender, lineToRender_fn).call(this, spinnerSymbol);
  import_node_readline.default.clearLine(this.stream, 0);
  this.stream.write(line);
  import_node_readline.default.moveCursor(this.stream, -(0, import_wcwidth.default)(line), moveCursorPos);
};
_stop = new WeakSet();
stop_fn = function(text) {
  this.text = text;
  __privateSet(this, _started, false);
  if (__privateGet(this, _interval) !== null) {
    clearInterval(__privateGet(this, _interval));
  }
};

// src/computeWithSpinner.ts
var kDefaultSafeLogger = () => void 0;
async function computeWithSpinner(asynchronousOp, options, logs = {}) {
  const { success = kDefaultSafeLogger, fail = kDefaultSafeLogger } = logs;
  const spinner = new Spinner(options.spinner).start(options.text, { withPrefix: options.withPrefix });
  try {
    const response = await asynchronousOp(spinner);
    spinner.succeed(success(spinner.elapsedTime));
    return response;
  } catch (err) {
    spinner.failed(fail(err));
    throw err;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Spinner,
  computeWithSpinner
});
