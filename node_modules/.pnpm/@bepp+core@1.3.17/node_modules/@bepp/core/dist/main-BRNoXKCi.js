import { join, resolve, basename } from "node:path";
import { homedir } from "node:os";
import { stat, access, constants, writeFile, mkdir, readFile, rm } from "node:fs/promises";
import yaml from "js-yaml";
import toml from "toml";
import compressing from "compressing";
import { createWriteStream } from "node:fs";
import zipDir from "zip-dir";
import { spawn } from "node:child_process";
import { Spinner } from "@topcli/spinner";
import pino from "pino";
import chalk from "chalk";
import pretty from "pino-pretty";
import enquirer from "enquirer";
import Ajv from "ajv";
import { resolve as resolve$1 } from "path";
const compressTypes = {
  tar: "tar",
  tgz: "tgz",
  gzip: "gzip",
  zip: "zip"
};
const compressionExtsTypes = {
  [compressTypes.tar]: ".tar",
  [compressTypes.tgz]: ".tar.gz",
  [compressTypes.gzip]: ".gz",
  [compressTypes.zip]: ".zip"
};
const manVersions = {
  3: "3",
  2: "2",
  none: "none"
};
const manTypes = {
  chromium: "chromium",
  chromiumMv2: "chromium-mv2",
  firefox: "firefox",
  firefoxMv2: "firefox-mv2"
};
const extTypes = {
  chromium: "chromium",
  firefox: "firefox",
  all: "all"
};
const browserTypes = {
  chrome: "chrome",
  chromeMv2: "chrome-mv2",
  chromium: "chromium",
  chromiumMv2: "chromium-mv2",
  firefox: "firefox",
  firefoxMv2: "firefox-mv2",
  yandex: "yandex",
  yandexMv2: "yandex-mv2",
  edge: "edge",
  edgeMv2: "edge-mv2",
  safari: "safari",
  safariMv2: "safari-mv2",
  // safariIos   : 'safari-ios',
  brave: "brave",
  opera: "opera",
  operagx: "opera-gx",
  custom: "custom"
};
class Fs {
  join = join;
  getAbsolutePath = resolve;
  validateHomeDir(path) {
    let resolvedPath = path;
    if (path.startsWith("~/")) {
      resolvedPath = path.replace(/^~(?=$|\/|\\)/, homedir());
    }
    return this.getAbsolutePath(resolvedPath);
  }
  async createImageFromBase64(base64String, outputPath) {
    const matches = base64String.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
    if (!matches) throw Error("Invalid base image");
    const base64Data = matches[2];
    const buffer = Buffer.from(base64Data, "base64");
    await this.writeFile(outputPath, buffer);
  }
  async isDirectory(path) {
    path = this.validateHomeDir(path);
    const stats = await stat(path);
    return stats.isDirectory();
  }
  async existsFile(path) {
    try {
      path = this.validateHomeDir(path);
      await access(path);
      const stats = await stat(path);
      return stats.isFile();
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      } else {
        throw error;
      }
    }
  }
  async existsDir(path) {
    try {
      path = this.validateHomeDir(path);
      await access(path, constants.F_OK);
      const stats = await stat(path);
      return stats.isDirectory();
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      } else {
        throw error;
      }
    }
  }
  async existsPath(path) {
    path = this.validateHomeDir(path);
    const isFile = await this.existsFile(path);
    if (isFile) return true;
    const isDir = await this.existsDir(path);
    return isDir;
  }
  async writeFile(path, content) {
    path = this.validateHomeDir(path);
    await writeFile(path, content);
  }
  async createDir(path) {
    try {
      path = this.validateHomeDir(path);
      await mkdir(path, {
        recursive: true
      });
    } catch (error) {
      throw Error(`Error al crear el directorio: ${error}`);
    }
  }
  async getDataFromJSONFile(path) {
    try {
      path = this.validateHomeDir(path);
      const fileContentBuffer = await readFile(path);
      const fileContent = fileContentBuffer.toString("utf8");
      return JSON.parse(fileContent);
    } catch (error) {
      throw new Error(`Error reading JSON file ${path}: ${error.message}`);
    }
  }
  async getDataFromYAMLFile(path) {
    try {
      path = this.validateHomeDir(path);
      const fileContentBuffer = await readFile(path);
      const fileContent = fileContentBuffer.toString("utf8");
      return yaml.load(fileContent);
    } catch (error) {
      throw new Error(`Error reading YAML file ${path}: ${error.message}`);
    }
  }
  async getDataFromTOMLFile(path) {
    try {
      path = this.validateHomeDir(path);
      const fileContentBuffer = await readFile(path);
      const fileContent = fileContentBuffer.toString("utf8");
      return toml.parse(fileContent);
    } catch (error) {
      throw new Error(`Error reading TOML file ${path}: ${error.message}`);
    }
  }
  async getDataFromFile(path) {
    try {
      const exists = await this.existsFile(path);
      if (!exists) throw Error("File does not exists");
      let data;
      if (path.endsWith(".json")) {
        data = await this.getDataFromJSONFile(path);
      } else if (path.endsWith(".yaml") || path.endsWith(".yml")) {
        data = await this.getDataFromYAMLFile(path);
      } else if (path.endsWith(".toml")) {
        data = await this.getDataFromTOMLFile(path);
      } else
        throw new Error("Unsupported file format. Expected JSON, YAML or TOML.");
      if (typeof data !== "object" || data === null)
        throw new Error("Data is not an object.");
      return data;
    } catch (error) {
      throw new Error(`Error reading file ${path}: ${error.message}`);
    }
  }
  getCompressOutputPath(out, name2, f) {
    return this.join(out, name2 + compressionExtsTypes[f]);
  }
  async removeDirIfExist(path) {
    path = this.validateHomeDir(path);
    const exists = await this.existsDir(path);
    if (exists) await this.removeDir(path);
  }
  async removeDir(path) {
    try {
      path = this.validateHomeDir(path);
      await rm(path, {
        recursive: true,
        force: true
      });
    } catch (error) {
      throw new Error(`Error removimg ${path}: ${error.message}`);
    }
  }
  async compress({ inputPath, outputPath, outputName, format }) {
    try {
      const compressOutputPath = this.getCompressOutputPath(outputPath, outputName, format);
      inputPath = this.validateHomeDir(inputPath);
      const isDir = await this.existsDir(inputPath);
      const compressFunct = isDir ? "compressDir" : "compressFile";
      const opts = isDir ? {
        ignoreBase: true,
        relativePath: outputName
      } : void 0;
      if (format === compressTypes.tar)
        await compressing.tar[compressFunct](inputPath, compressOutputPath, opts);
      else if (format === compressTypes.tgz)
        await compressing.tgz[compressFunct](inputPath, compressOutputPath, opts);
      else if (format === compressTypes.gzip)
        await compressing.tgz[compressFunct](inputPath, compressOutputPath, opts);
      else if (format === compressTypes.zip) {
        if (isDir) {
          const buffer = await zipDir(inputPath, {
            filter: (path) => basename(path) !== ".DS_Store"
          });
          const outputStream = createWriteStream(compressOutputPath);
          outputStream.write(buffer);
          outputStream.end();
          await new Promise((resolve2, reject) => {
            outputStream.on("close", resolve2);
            outputStream.on("error", reject);
          });
        } else
          await compressing.zip[compressFunct](inputPath, createWriteStream(compressOutputPath), opts);
      } else throw "Format no supported";
    } catch (error) {
      throw new Error(`Error in compression ${inputPath}: ${error.message}`);
    }
  }
  async decompress({ inputPath, outputPath, format }) {
    try {
      outputPath = this.validateHomeDir(outputPath);
      const isDir = await this.existsDir(outputPath);
      if (!isDir) throw new Error(`Output path ${outputPath} is not a directory.`);
      if (format === compressTypes.tar)
        await compressing.tar.uncompress(inputPath, outputPath);
      else if (format === compressTypes.tgz)
        await compressing.tgz.uncompress(inputPath, outputPath);
      else if (format === compressTypes.gzip)
        await compressing.gzip.uncompress(inputPath, outputPath);
      else if (format === compressTypes.zip)
        await compressing.zip.uncompress(inputPath, outputPath);
      else throw new Error("Format not supported");
    } catch (error) {
      throw new Error(`Error in decompression ${inputPath}: ${error.message}`);
    }
  }
}
class ChildProcess {
  async execute({
    cmd,
    onError,
    onLog
  }) {
    return new Promise((resolve2, reject) => {
      const childProcess = spawn(cmd, {
        shell: true,
        stdio: [
          "inherit",
          "pipe",
          "pipe"
        ]
        // Redirigir la salida estÃ¡ndar y de error a cauces
      });
      childProcess.stdout.on("data", (data) => {
        onLog(data.toString());
      });
      childProcess.stderr.on("data", (data) => {
        onLog(data.toString());
      });
      childProcess.on("close", (code) => {
        if (code === 0) {
          resolve2();
        } else {
          const error = new Error(`Command failed with code ${code}`);
          onError(error);
          reject(error);
        }
      });
      childProcess.on("error", (error) => {
        onError(error);
        reject(error);
      });
    });
  }
  async exec(cmd) {
    await new Promise((resolve2, reject) => {
      const childProcess = spawn(cmd, {
        shell: true,
        stdio: "inherit"
      });
      childProcess.on("close", (code) => {
        if (code === 0) {
          resolve2();
        } else {
          const error = new Error(`Command failed with code ${code}`);
          console.error(error);
          reject(error);
        }
      });
    });
  }
}
class Logger {
  log = pino(
    {
      level: "debug"
    },
    pretty(
      {
        colorize: true,
        ignore: "pid,hostname,time"
      }
    )
  );
  verbose = false;
  spinner(withPrefix) {
    const instance = new Spinner({
      name: "line"
    });
    return {
      start: (txt) => {
        if (this.verbose) {
          this.info(txt);
        } else {
          instance.start(txt, {
            withPrefix: chalk.blue(withPrefix) + " - "
          });
        }
      },
      changeText: (txt) => {
        if (this.verbose) {
          this.info(txt);
        } else {
          instance.text = txt;
        }
      },
      getTime: () => instance.elapsedTime.toFixed(2),
      succeed: (txt) => {
        if (this.verbose) {
          this.info(txt);
        } else {
          instance.succeed(chalk.green(txt));
        }
      },
      failed: (txt) => {
        if (this.verbose) {
          this.error(txt);
        } else {
          instance.failed(chalk.red(txt));
        }
      },
      reset: () => Spinner.reset(),
      verbose: (data) => this.info(data),
      verboseError: (data) => this.fatal(data)
    };
  }
  ask = enquirer.prompt;
  // async ask( questions: Parameters<typeof enquirer.prompt>[0] ){
  // 	return await enquirer.prompt( questions )
  // }
  time() {
    let start, stop;
    return {
      start: () => {
        start = performance.now();
      },
      stop: () => {
        stop = performance.now();
      },
      getResult: () => {
        if (start && stop) return stop - start;
        return false;
      }
    };
  }
  forceInfo(data) {
    this.log.info(data);
  }
  info(data) {
    if (this.verbose) this.log.info(data);
  }
  error(data) {
    this.log.error(data);
  }
  warn(data) {
    if (this.verbose) this.log.warn(data);
  }
  debug(data) {
    if (this.verbose) this.log.debug(data);
  }
  fatal(data) {
    this.log.fatal(data);
    process.exit(1);
  }
}
class VarString {
  formatSpaces(string, spaceFormat = "--") {
    return string.toLowerCase().replace(/ /g, spaceFormat);
  }
  capitalizeFirstLetter(str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1);
  }
  replacePlaceholders(inputString, replacements) {
    const regex = /\{\{([^}]+)\}\}/g;
    const replacer = (_, placeholder) => replacements[placeholder] || "";
    return inputString.replace(regex, replacer);
  }
}
class VarObj {
  async validateWithSchema(data, schema2, verbose = false) {
    const ajv = new Ajv();
    const validate = ajv.compile(schema2);
    const valid = validate(data);
    if (!valid) {
      const errors = validate.errors?.map((error) => {
        return {
          instancePath: error.instancePath,
          message: error.message
        };
      });
      const errorString = verbose ? JSON.stringify(validate.errors, null, 2) : JSON.stringify(errors);
      throw new Error(`Object validation error: ${errorString}`);
    }
  }
}
class Vars {
  string = new VarString();
  object = new VarObj();
}
const name = "bepp";
const description = "A tool to quickly and easily package your extension for multiple browsers (including Safari)";
const extra = {
  productName: "Bepp",
  libraryUrl: "https://www.npmjs.com/package/@bepp/bepp",
  libraryId: "@bepp/bepp",
  defaultApiPort: "13129",
  defaultAppPort: "13128",
  rawRepoUrl: "https://raw.githubusercontent.com/pigeonposse/bepp",
  ghActionUrl: "https://github.com/marketplace/actions/bepp-a-cross-browser-extension-builder",
  docsUrl: "https://bepp.pigeonposse.com",
  docsPath: {
    posts: "/posts/",
    todo: "/todo/",
    guide: "/guide/",
    app: "/guide/app/",
    api: "/guide/api/",
    lib: "/guide/lib/",
    container: "/guide/container/",
    gh: "/guide/gh-action/"
  },
  collective: {
    id: "pigeonposse",
    name: "PigeonPosse",
    gh: "https://github.com/pigeonposse",
    about: "https://pigeonposse.com?popup=about",
    url: "https://pigeonposse.com",
    web: "https://pigeonposse.com",
    email: "dev@pigeonposse.com",
    social: {
      twitter: "https://twitter.com/pigeonposse_",
      instagram: "https://www.instagram.com/pigeon.posse/",
      medium: "https://medium.com/@pigeonposse"
    }
  },
  downloadUrl: {
    containerDocker: {
      name: "Docker image",
      logo: "docker",
      url: "https://hub.docker.com/r/pigeonposse/bepp",
      type: "container"
    },
    containerGithub: {
      name: "Github package",
      url: "https://github.com/pigeonposse/bepp/pkgs/container/bepp",
      type: "container"
    },
    macosUniversal: {
      name: "MacOS App (Universal)",
      logo: "apple",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_x64.app.tar.gz",
      type: "desktop"
    },
    macosIntel: {
      name: "MacOS App (Intel)",
      logo: "apple",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_x64.app.tar.gz",
      type: "desktop"
    },
    macosArm: {
      name: "MacOS App (ARM)",
      logo: "apple",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_aarch64.app.tar.gz",
      type: "desktop"
    },
    windowsExe: {
      name: "Windows App (.exe)",
      logo: "windows",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_1.3.17_x64-setup.exe",
      type: "desktop",
      "update-version": true
    },
    windowsMSI: {
      name: "Windows App (.msi)",
      logo: "windows",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_1.3.17_x64-setup.nsis.zip",
      type: "desktop",
      "update-version": true
    },
    linuxAppImage: {
      name: "Linux App (.AppImage)",
      logo: "linux",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_1.3.17_amd64.AppImage.tar.gz",
      type: "desktop",
      "update-version": true
    },
    linuxDeb: {
      name: "Linux App (.deb)",
      logo: "linux",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app_1.3.17_amd64.deb",
      type: "desktop",
      "update-version": true
    },
    linuxRpm: {
      name: "Linux App (.rpm)",
      logo: "linux",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-app-1.3.17-1.x86_64.rpm",
      type: "desktop",
      "update-version": true
    },
    binLinuxX64: {
      name: "bepp-core (Linux x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-linux-x64.zip",
      type: "bin"
    },
    binLinuxArm64: {
      name: "bepp-core (Linux Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-linux-arm64.zip",
      type: "bin"
    },
    binMacosX64: {
      name: "bepp-core (MacOS x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-macos-x64.zip",
      type: "bin"
    },
    binMacosArm64: {
      name: "bepp-core (MacOS Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-macos-arm64.zip",
      type: "bin"
    },
    binAlpineX64: {
      name: "bepp-core (Alpine x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-alpine-x64.zip",
      type: "bin"
    },
    binAlpineArm64: {
      name: "bepp-core (Alpine Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-alpine-arm64.zip",
      type: "bin"
    },
    binWinX64: {
      name: "bepp-core (Windows x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-win-x64.exe.zip",
      type: "bin"
    },
    binWinArm64: {
      name: "bepp-core (Windows Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-core-win-arm64.exe.zip",
      type: "bin"
    },
    binApiLinuxX64: {
      name: "bepp-api (Linux x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-linux-x64.zip",
      type: "bin"
    },
    binApiLinuxArm64: {
      name: "bepp-api (Linux Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-linux-arm64.zip",
      type: "bin"
    },
    binApiMacosX64: {
      name: "bepp-api (MacOS x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-macos-x64.zip",
      type: "bin"
    },
    binApiMacosArm64: {
      name: "bepp-api (MacOS Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-macos-arm64.zip",
      type: "bin"
    },
    binApiAlpineX64: {
      name: "bepp-api (Alpine x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-alpine-x64.zip",
      type: "bin"
    },
    binApiAlpineArm64: {
      name: "bepp-api (Alpine Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-alpine-arm64.zip",
      type: "bin"
    },
    binApiWinX64: {
      name: "bepp-api (Windows x64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-win-x64.exe.zip",
      type: "bin"
    },
    binApiWinArm64: {
      name: "bepp-api (Windows Arm64)",
      logo: "gnubash",
      url: "https://github.com/pigeonposse/bepp/releases/latest/download/bepp-api-win-arm64.exe.zip",
      type: "bin"
    }
  }
};
const version = "1.3.17";
class SuperCore {
  fs = new Fs();
  log = new Logger();
  type = new Vars();
  childProcess = new ChildProcess();
  id = name;
  version = version;
  isMacos() {
    return process.platform === "darwin";
  }
  globalDefaultParams = {
    verbose: false,
    exit: false,
    time: false
  };
  globalDataQuestion = {
    overwrite: {
      id: "overwrite",
      default: true
    }
  };
  async askOverwriteConfigFile() {
    const res = await this.log.ask([
      {
        type: "confirm",
        name: this.globalDataQuestion.overwrite.id,
        message: "Configuration file detected. Do you want to overwrite it?",
        initial: this.globalDataQuestion.overwrite.default
      }
    ]);
    return this.globalDataQuestion.overwrite.id in res ? res[this.globalDataQuestion.overwrite.id] : this.globalDataQuestion.overwrite.default;
  }
  async setFunctionConstructor({ name: name2, defaultValues, values, cb }) {
    const v = {
      ...defaultValues,
      ...values
    };
    this.log.verbose = values.verbose || false;
    const log = this.log.spinner(name2);
    const time = this.log.time();
    time.start();
    try {
      log.verbose({
        title: "Init data:",
        value: values
      });
      await cb({
        log,
        values: v
      });
    } catch (e) {
      log.failed(e.message) || this.log.fatal(e.message);
      if (values.exit) process.exit(1);
    } finally {
      time.stop();
      if (values.time) {
        const elapsedTime = time.getResult().toString();
        if (this.log.verbose) {
          this.log.info({
            title: `[${name2}] Execution time`,
            value: {
              miliseconds: elapsedTime,
              seconds: Number(elapsedTime) / 1e3
            }
          });
        } else {
          this.log.forceInfo(`[${name2}] Execution time: ${Number(elapsedTime) / 1e3} seconds`);
        }
      }
    }
  }
}
class InitCore extends SuperCore {
  configPathName = `${this.id}.config.json`;
  configPath = this.fs.getAbsolutePath(this.configPathName);
  defaultParams = {
    ...this.globalDefaultParams,
    y: false,
    id: this.id,
    build: [
      browserTypes.chrome,
      browserTypes.chromium
    ]
  };
  dataQuestion = {
    ...this.globalDataQuestion,
    id: {
      id: "id",
      default: this.defaultParams.id
    },
    input: {
      id: "input",
      default: "./exts/chrome"
    },
    build: {
      id: "build",
      default: this.defaultParams.build
    }
  };
  async #askCreate(values) {
    const questions = [];
    const res = values;
    if (!values.build) {
      questions.push({
        type: "multiselect",
        name: this.dataQuestion.build.id,
        message: "Select list of browser for build",
        // @ts-ignore
        choices: Object.values(browserTypes),
        initial: this.dataQuestion.build.default
      });
    }
    if (!values.id) {
      questions.push({
        type: "input",
        name: this.dataQuestion.id.id,
        message: "Write a ID for your build. This is used for package name",
        initial: this.dataQuestion.id.default,
        validate: (input) => {
          if (input.includes(" ")) return "The string cannot contain spaces";
          return true;
        }
      });
    }
    if (!values.input) {
      questions.push({
        type: "input",
        name: this.dataQuestion.input.id,
        message: "Write a input path for where your Chrome extension is located",
        initial: this.dataQuestion.input.default
      });
    }
    const answers = await this.log.ask(questions);
    return {
      ...res,
      ...answers
    };
  }
  async existsConfigFile() {
    return await this.fs.existsFile(this.configPath);
  }
  async create(values) {
    const initValues = values;
    await this.setFunctionConstructor({
      name: "init",
      defaultValues: this.defaultParams,
      values: initValues,
      cb: async ({ values: values2 }) => {
        const fileExists = await this.existsConfigFile();
        let override = true;
        if (!values2.y && fileExists) override = await this.askOverwriteConfigFile();
        if (!override && fileExists) {
          throw new Error(`Config File [${this.configPath}] already exists`);
        } else {
          const data = await this.#askCreate(values2.y ? {
            input: this.dataQuestion.input.default,
            ...values2
          } : initValues);
          if (data.input !== "string") this.log.fatal("Input must be a string");
          const build = data.build ? data.build.map((d) => ({
            type: d
          })) : [];
          const schemaUrl = this.version ? `https://raw.githubusercontent.com/pigeonposse/bepp/${this.version}/packages/core/schema.json` : "https://raw.githubusercontent.com/pigeonposse/bepp/main/packages/core/schema.json";
          const defaultConfig = {
            $schema: schemaUrl,
            shared: {
              id: data.id,
              input: {
                chromium: data.input
              }
            },
            build
          };
          await this.fs.writeFile(
            this.configPath,
            JSON.stringify(defaultConfig, null, 2)
          );
        }
      }
    });
  }
}
const core$b = new InitCore();
const init = async (values) => await core$b.create(values);
class BuildSharedCore extends SuperCore {
  browsersIds = browserTypes;
  globalBuildDefaultParams = {
    ...this.globalDefaultParams,
    id: this.id,
    output: this.fs.join("build", "extensions"),
    compress: compressTypes.tgz,
    filename: "{{id}}-{{browser}}-{{version}}"
  };
}
const $schema = "http://json-schema.org/draft-07/schema#";
const $ref = "#/definitions/BuildConfigSchema";
const definitions = {
  BuildConfigSchema: {
    type: "object",
    additionalProperties: false,
    properties: {
      $schema: {
        type: [
          "string",
          "null"
        ],
        description: "The JSON schema for the bepp config.  Bepp has his own schema in: https://raw.githubusercontent.com/pigeonposse/bepp/main/packages/core/schema.json"
      },
      shared: {
        type: "object",
        additionalProperties: false,
        properties: {
          input: {
            type: "object",
            properties: {
              chromium: {
                type: "string"
              },
              "chromium-mv2": {
                type: "string"
              },
              firefox: {
                type: "string"
              },
              "firefox-mv2": {
                type: "string"
              }
            },
            additionalProperties: false
          },
          verbose: {
            type: "boolean"
          },
          time: {
            type: "boolean"
          },
          exit: {
            type: "boolean"
          },
          id: {
            type: "string"
          },
          output: {
            type: "string"
          },
          compress: {
            type: "string",
            "enum": [
              "tar",
              "tgz",
              "gzip",
              "zip"
            ],
            description: "Compression type."
          },
          filename: {
            type: "string"
          }
        },
        description: "Data for shared with your builds."
      },
      build: {
        type: "array",
        items: {
          anyOf: [
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "chrome"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "chrome-mv2"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "chromium"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "chromium-mv2"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "firefox"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "firefox-mv2"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                appId: {
                  type: "string"
                },
                appTitle: {
                  type: "string"
                },
                onlyXcodeProject: {
                  type: "boolean"
                },
                dmgIcon: {
                  type: "string"
                },
                dmgNoReadme: {
                  type: "boolean"
                },
                dmgReadmePath: {
                  type: "string"
                },
                dmgReadmeFilename: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "safari"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                appId: {
                  type: "string"
                },
                appTitle: {
                  type: "string"
                },
                onlyXcodeProject: {
                  type: "boolean"
                },
                dmgIcon: {
                  type: "string"
                },
                dmgNoReadme: {
                  type: "boolean"
                },
                dmgReadmePath: {
                  type: "string"
                },
                dmgReadmeFilename: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "safari-mv2"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "edge"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "edge-mv2"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "brave"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "opera"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "opera-gx"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "yandex"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "yandex-mv2"
                }
              },
              required: [
                "type"
              ]
            },
            {
              type: "object",
              additionalProperties: false,
              properties: {
                verbose: {
                  type: "boolean"
                },
                time: {
                  type: "boolean"
                },
                exit: {
                  type: "boolean"
                },
                id: {
                  type: "string"
                },
                output: {
                  type: "string"
                },
                compress: {
                  type: "string",
                  "enum": [
                    "tar",
                    "tgz",
                    "gzip",
                    "zip"
                  ],
                  description: "Compression type."
                },
                filename: {
                  type: "string"
                },
                input: {
                  type: "string"
                },
                browserName: {
                  type: "string"
                },
                type: {
                  type: "string",
                  "const": "custom"
                }
              },
              required: [
                "type"
              ]
            }
          ]
        },
        description: "Set the browsers you want build."
      }
    }
  }
};
const schema = {
  $schema,
  $ref,
  definitions
};
class BuildBrowserSharedCore extends BuildSharedCore {
  defaultParams = {
    ...this.globalBuildDefaultParams
  };
  ERROR = {
    NO_INPUT: "no-input",
    NO_MAN: "no-man",
    NO_MAN_VER: "no-man-version"
  };
  async buildBrowserConstructor({
    props,
    cb,
    onError
  }) {
    const { inputPath, name: name2, man, target } = props;
    const cliValues = props.values;
    await this.setFunctionConstructor({
      name: name2,
      defaultValues: this.defaultParams,
      // @ts-ignore
      values: cliValues,
      cb: async ({ log, values }) => {
        log.start(`Staring building [${name2}] package`);
        const manPath = this.fs.join(inputPath || "", "manifest.json");
        try {
          if (!inputPath) throw new Error(this.ERROR.NO_INPUT);
          const existsDir = await this.fs.existsDir(values.output);
          if (!existsDir) await this.fs.createDir(values.output);
          const manifest = await this.fs.getDataFromJSONFile(manPath);
          if (!manifest) throw new Error(this.ERROR.NO_MAN);
          const exists = man === manVersions.none ? true : Number(manifest.manifest_version) === Number(man);
          if (!exists) throw new Error(this.ERROR.NO_MAN_VER);
          values.filename = this.type.string.replacePlaceholders(values.filename, {
            id: values.id,
            browser: name2,
            version: manifest.version || ""
          });
          await cb({
            ...cliValues,
            // It is the first to avoid overwriting
            ...values,
            input: inputPath,
            manifestPath: manPath,
            manifestProps: manifest,
            log
          });
        } catch (e) {
          const error = e.message;
          if (error === this.ERROR.NO_INPUT)
            log.failed(target === extTypes.all ? `An Extension input path required` : `${this.type.string.capitalizeFirstLetter(target)} Extension input path required`);
          else if (error === this.ERROR.NO_MAN)
            log.failed(`Input not has Manifest`);
          else if (error === this.ERROR.NO_MAN_VER)
            log.failed(`Manifest path [${manPath}] must have: "manifest_version": "${man}"`);
          else {
            onError({ error, log, ...values });
          }
        }
      }
    });
  }
  async buildBrowser(props) {
    await this.buildBrowserConstructor({
      props,
      cb: async (params) => {
        params.log.verbose({
          title: "All Params for compresion",
          value: params
        });
        await this.fs.compress({
          inputPath: params.input,
          outputPath: params.output,
          outputName: params.filename,
          format: params.compress
        });
        const compressFile = this.fs.getCompressOutputPath(params.output, params.filename, params.compress);
        params.log.succeed(`Builded in: ${compressFile}`);
      },
      onError: ({ log, error }) => {
        log.failed(error);
      }
    });
  }
  async buildBrowserWithProps(props, values) {
    await this.buildBrowser({
      target: props.target,
      name: props.name,
      inputPath: values.input,
      values,
      man: props.man
    });
  }
}
class BuildChromeMV2Core extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.chromeMv2,
    target: extTypes.chromium,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
class BuildChromeCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.chrome,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    await Promise.all([
      this.buildBrowserWithProps(this.props, values),
      values.inputMv2 ? new BuildChromeMV2Core().create({ ...values, input: values.inputMv2 }) : Promise.resolve()
    ]);
  }
}
const core$a = new BuildChromeCore();
const coreMv2$5 = new BuildChromeMV2Core();
const chrome = {
  props: core$a.props,
  /**
   * Build Chrome extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/chrome
   */
  build: core$a.create.bind(core$a),
  mv2: {
    /**
     * Build Chrome extension (manifest 2).
     *
     * @returns {Promise<void>}                    
     * @see https://bepp.pigeonposse.com/guide/build/chrome
     */
    build: coreMv2$5.create.bind(coreMv2$5),
    props: coreMv2$5.props
  }
};
class BuildChromiumMV2Core extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.chromiumMv2,
    target: extTypes.chromium,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
class BuildChromiumCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.chromium,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    await Promise.all([
      this.buildBrowserWithProps(this.props, values),
      values.inputMv2 ? new BuildChromiumMV2Core().create({ ...values, input: values.inputMv2 }) : Promise.resolve()
    ]);
  }
}
const core$9 = new BuildChromiumCore();
const coreMv2$4 = new BuildChromiumMV2Core();
const chromium = {
  props: core$9.props,
  /**
   * Build Chromium extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/chromium
   */
  build: core$9.create.bind(core$9),
  mv2: {
    /**
     * Build Chromium extension (manifest 2).
     *
     * @returns {Promise<void>}                    
     * @see https://bepp.pigeonposse.com/guide/build/chromium
     */
    build: coreMv2$4.create.bind(coreMv2$4),
    props: coreMv2$4.props
  }
};
class BuildFirefoxMV2Core extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.firefoxMv2,
    target: extTypes.firefox,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
class BuildFirefoxCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.firefox,
    target: extTypes.firefox,
    man: manVersions[3]
  };
  async create(values) {
    await Promise.all([
      this.buildBrowserWithProps(this.props, values),
      values.inputMv2 ? new BuildFirefoxMV2Core().create({ ...values, input: values.inputMv2 }) : Promise.resolve()
    ]);
  }
}
const core$8 = new BuildFirefoxCore();
const coreMv2$3 = new BuildFirefoxMV2Core();
const firefox = {
  props: core$8.props,
  /**
   * Build Firefox extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/firefox
   */
  build: core$8.create.bind(core$8),
  mv2: {
    /**
     * Build Firefox extension (manifest 2).
     *
     * @returns {Promise<void>}                    
     * @see https://bepp.pigeonposse.com/guide/build/firefox
     */
    build: coreMv2$3.create.bind(coreMv2$3),
    props: coreMv2$3.props
  }
};
class BuildEdgeMV2Core extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.edgeMv2,
    target: extTypes.chromium,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
class BuildEdgeCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.edge,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    await Promise.all([
      this.buildBrowserWithProps(this.props, values),
      values.inputMv2 ? new BuildEdgeMV2Core().create({ ...values, input: values.inputMv2 }) : Promise.resolve()
    ]);
  }
}
const core$7 = new BuildEdgeCore();
const coreMv2$2 = new BuildEdgeMV2Core();
const edge = {
  props: core$7.props,
  /**
   * Build Edge extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/edge
   */
  build: core$7.create.bind(core$7),
  mv2: {
    /**
     * Build Edge extension (manifest 2).
     *
     * @returns {Promise<void>}                    
     * @see https://bepp.pigeonposse.com/guide/build/edge
     */
    build: coreMv2$2.create.bind(coreMv2$2),
    props: coreMv2$2.props
  }
};
const appTypes = {
  ios: "iOS",
  macos: "macOS"
};
const bgURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAApQAAAGQCAMAAAAnaACFAAAAAXNSR0IArs4c6QAAAEtQTFRF////+fj57uzv4t7h1dPXz8zQxsPH567FvLe6rqy2pqCn2G+WPKaxaIWsj2uZz0l8tUSBMnOcyCpvlTt9fDp8P0iHay11YipzHESFBOV5/gAAAyRJREFUeNrs3NGOqjgAgOGWQqd0RgWFGd//SbforHuyc7LJXhhMzvcZaeH6D0VEAwAAAAAAAAAAAAAAAADwG93bmAK8ju7tfVqW2gV4DfHt/XSalq/PY+ligN3F1JK8RfnVssyyZG8xvZ3O51Nz+fxqluNgEWdXXVu5z03bTJdly/JzqX2A/Wwr9/lumh5ZBtjFzygfWQbYyc8om+VTlOzq/e8kT9NluUzNRZTs69Hk7T7lRZTs7RHl933KRZT8F1Hyhzq1Hs/NtKzXVZS8glPTmrys1816ESW7etwSuhw+5mszfxyOomRvLcrp+LGZ59twWNw8Z1/v07JuOT7M11WU7Oq43tftR5KbNcB+8mG9PrKc700exgA76sbD9Wb+TnIek8d82Vka5+vDXHtJsr/Y1+8s14PHznkRXX+7tDxkSfI6uuFw8JsxAAD+txi/R9eS7KcvJXfhLoc+hRiaNv5iKGWIIZeS2zSnENu+anmaVmRX7iW2bZ9ibvNtDP8Yy1D7WHOf2rTUmOpQc4DnRRlLKCGkoW37NIxblX3JJbUjobSdWPuuplS7GOJtzGMoouRpcilj90uUXQ5Nv/XYXre9VGsdwtC2MdUyltDe1V9X8tQz5fgzyrRFOaShjS3HmGsoJcY2zX0MtfjukedGGVqUMfT/OlPGEmIuoSmlK2OouetC2Q50/kqVZy/fpQ+p5HyPMpTbNWXOJYXQjjVjrWPqaq05jNuBvgZ4vvjbqccxeDHd4CM2LyY6TwIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPBXe3BIAAAAACDo/2tX2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAVnFiOqbc33/AAAAABJRU5ErkJggg==";
class BuildSafariSharedCore extends BuildBrowserSharedCore {
  defaultSafariParams = {
    appId: `com.${this.id}.{{id}}`,
    appTitle: "{{id}} (Safari extension)",
    dmgIcon: void 0,
    dmgNoReadme: void 0,
    dmgReadmeFilename: "README.md",
    dmgReadmePath: void 0,
    onlyXcodeProject: false
  };
  requirementFileData(name2) {
    return `# ${name2} (Safari Extension) [Unsigned macOS version]

## ð ï¸ Steps to activate the extension

1. Move app to "/Applications" folder
2. Allow Unsigned Extensions in Safari App. How:

    1. Open Safari and choose Safari > Settings.
    2. Select the Advanced tab, then select the "Show Develop menu in menu bar" checkbox.
    3. Choose Develop > Allow Unsigned Extensions, enter your password, and click OK. If you are using Safari 17 or later, click the Developer tab in Safari Settings, and select the "Allow unsigned extensions" option. The Allow Unsigned Extensions setting resets when a user quits Safari, so you need to set it again the next time you launch Safari.
    4. Choose Safari > Settings and click the Extensions tab. This tab shows the localized description, display name, and version number for the selected Safari app extension. It also provides a more nuanced message about the permissions for the extension.
    5. Find your new extension in the list on the left, and enable it by selecting its checkbox.
    6. Close Safari Settings.

- [More info](http://pigeonposse.com/posts/how-to-open-unsigned-safari-extensions)
- [More Apple info](https://developer.apple.com/documentation/safariservices/safari_app_extensions/building_a_safari_app_extension#2957925)`;
  }
  async command_createDMG(scriptPath, options) {
    const CREATE_DMG_SCRIPT = scriptPath;
    const {
      DMG_OUTPUT_PATH,
      TITLE,
      ICON,
      APP_SOURCE,
      README_PATH,
      README_FILE_NAME,
      BG_IMG_PATH
    } = options;
    let command;
    if (README_PATH) {
      command = `bash ${CREATE_DMG_SCRIPT} 				--volname "${TITLE}" 				--volicon "${ICON}" 				--background "${BG_IMG_PATH}" 				--window-size 660 400 				--icon-size 80 				--text-size 12 				--add-file "${README_FILE_NAME}" "${README_PATH}" 330 120 				--app-drop-link 448 240 				--icon "${TITLE}.app" 192 240 				--hide-extension "${TITLE}.app" 				"${DMG_OUTPUT_PATH}" 				"${APP_SOURCE}"`;
    } else {
      command = `bash ${CREATE_DMG_SCRIPT} 				--volname "${TITLE}" 				--volicon "${ICON}" 				--background "${BG_IMG_PATH}" 				--window-size 660 400 				--icon-size 80 				--text-size 12 				--app-drop-link 448 200 				--icon "${TITLE}.app" 192 200 				--hide-extension "${TITLE}.app" 				"${DMG_OUTPUT_PATH}" 				"${APP_SOURCE}"`;
    }
    return command;
  }
  getSafariParams(props, values) {
    const params = {
      ...values,
      appId: values.appId || this.defaultSafariParams.appId,
      appTitle: values.appTitle || this.defaultSafariParams.appTitle,
      dmgIcon: values.dmgIcon || this.defaultSafariParams.dmgIcon,
      dmgNoReadme: values.dmgNoReadme || this.defaultSafariParams.dmgNoReadme,
      dmgReadmeFilename: values.dmgReadmeFilename || this.defaultSafariParams.dmgReadmeFilename,
      dmgReadmePath: values.dmgReadmePath || this.defaultSafariParams.dmgReadmePath,
      onlyXcodeProject: values.onlyXcodeProject || this.defaultSafariParams.onlyXcodeProject
    };
    const placeholderProps = {
      id: params.id,
      browser: props.name,
      version: params.manifestProps.version || ""
    };
    params.appTitle = this.type.string.replacePlaceholders(params.appTitle, placeholderProps);
    params.appTitle = this.type.string.replacePlaceholders(params.appTitle, placeholderProps);
    return params;
  }
  async buildDmg(props, params, type) {
    const SAFARI_TEMP_PATH = this.fs.join(params.output, "__temp-" + props.name + "-" + type);
    try {
      params = this.getSafariParams(props, params);
      params.log.verbose({
        title: "Debug Safari params",
        values: params
      });
      const logFuncts = {
        onError: (error) => {
          if (error && error.message)
            params.verbose ? params.log.verboseError(error.message) : params.log.failed(error.message);
        },
        onLog: (data) => {
          if (data)
            params.verbose ? params.log.verbose(data) : params.log.changeText(data);
        }
      };
      if (type !== appTypes.ios && type !== appTypes.macos) throw Error('Type incorrect. Must be "iOS" or "macOS".');
      await this.fs.removeDirIfExist(SAFARI_TEMP_PATH);
      const PRODUCT_NAME = params.appTitle;
      const CHROME_PATH = params.input;
      const APP_ID = params.appId;
      const SAFARI_XCODEPROJECT_DIR_PATH = this.fs.join(SAFARI_TEMP_PATH, PRODUCT_NAME);
      const SAFARI_XCODEPROJECT_PATH = this.fs.join(SAFARI_XCODEPROJECT_DIR_PATH, `${PRODUCT_NAME}.xcodeproj`);
      const SAFARI_APP_BUILD_PATH = this.fs.join(SAFARI_TEMP_PATH, `app-${type}`);
      const SAFARI_APP_BUILD_RELEASE_PATH = this.fs.join(SAFARI_APP_BUILD_PATH, "Build", "Products", "Release", `${PRODUCT_NAME}.app`);
      const SAFARI_APP_ICNS_PATH = params.dmgIcon ? params.dmgIcon : this.fs.join(SAFARI_APP_BUILD_RELEASE_PATH, "Contents", "Resources", "AppIcon.icns");
      const typeFlag = type === appTypes.macos ? "--macos-only" : "--ios-only";
      params.log.changeText("ð Converting chrome to safari extension");
      const cmdConvertExt = `xcrun safari-web-extension-converter ${CHROME_PATH} 			    ${typeFlag}                 --project-location "${SAFARI_TEMP_PATH}"                 --app-name "${PRODUCT_NAME}"                 --bundle-identifier ${APP_ID} 				--swift                 --force                 --no-prompt                 --no-open
            `;
      params.log.verbose({
        title: "Converting chrome extensiom to safari extension",
        value: cmdConvertExt
      });
      await this.childProcess.execute({
        cmd: cmdConvertExt,
        ...logFuncts
      });
      if (!params.onlyXcodeProject) {
        params.log.changeText("ð Building safari app");
        let cmdBuildApp = `xcodebuild -project "${SAFARI_XCODEPROJECT_PATH}" 				-scheme "${PRODUCT_NAME}" 				-configuration Release 				-derivedDataPath "${SAFARI_APP_BUILD_PATH}"`;
        params.log.verbose({
          title: "Building safari app",
          value: cmdBuildApp
        });
        await this.childProcess.execute({
          cmd: cmdBuildApp,
          ...logFuncts
        });
      }
      let SAFARI_OOTPUT;
      if (type === appTypes.macos && !params.onlyXcodeProject) {
        params.log.changeText("ð Creating DMG");
        const SAFARI_DMG_OUTPUT = this.fs.join(SAFARI_TEMP_PATH, `${params.filename}.dmg`);
        const BG_IMG_PATH = this.fs.join(SAFARI_TEMP_PATH, "bg.png");
        await this.fs.createImageFromBase64(bgURL, BG_IMG_PATH);
        const DMG_CMD_PARAMS = {
          DMG_OUTPUT_PATH: SAFARI_DMG_OUTPUT,
          TITLE: PRODUCT_NAME,
          ICON: this.fs.getAbsolutePath(SAFARI_APP_ICNS_PATH),
          APP_SOURCE: this.fs.getAbsolutePath(SAFARI_APP_BUILD_RELEASE_PATH),
          README_PATH: void 0,
          README_FILE_NAME: params.dmgReadmeFilename,
          BG_IMG_PATH
        };
        if (!params.dmgNoReadme) {
          const README_DEFAULT_PATH = this.fs.join(SAFARI_TEMP_PATH, "safari-unsigned-info.md");
          if (!params.dmgReadmePath) await this.fs.writeFile(README_DEFAULT_PATH, this.requirementFileData(params.id));
          const README_PATH = params.dmgReadmePath || README_DEFAULT_PATH;
          const README_ABSOLUTE_PATH = this.fs.getAbsolutePath(README_PATH);
          DMG_CMD_PARAMS.README_PATH = README_ABSOLUTE_PATH;
        }
        const DMG_SCRIPT = {
          path: this.fs.join(SAFARI_TEMP_PATH, "create-dmg.sh"),
          // @ts-ignore
          content: '#!/usr/bin/env bash\n\n# Modificated copy of repo https://github.com/create-dmg/create-dmg\n\n# Create a read-only disk image of the contents of a folder\n\n# Bail out on any unhandled errors\nset -e;\n# Any command that exits with non-zero code will cause the pipeline to fail\nset -o pipefail;\n\nCDMG_VERSION=\'1.2.1\'\n\n# The full path to the "support/" directory this script is using\n# (This will be set up by code later in the script.)\nCDMG_SUPPORT_DIR=""\n\nOS_FULL_VERSION="$(sw_vers | sed -n 2p | cut -d : -f 2 | tr -d \'[:space:]\' | cut -c1-)"\nOS_MAJOR_VERSION="$(echo $OS_FULL_VERSION | cut -d . -f 1)"\nOS_MINOR_VERSION="$(echo $OS_FULL_VERSION | cut -d . -f 2)"\nWINX=10\nWINY=60\nWINW=500\nWINH=350\nICON_SIZE=128\nTEXT_SIZE=16\nFORMAT="UDZO"\nFILESYSTEM="HFS+"\nADD_FILE_SOURCES=()\nADD_FILE_TARGETS=()\nIMAGEKEY=""\nHDIUTIL_VERBOSITY=""\nSANDBOX_SAFE=0\nBLESS=0\nSKIP_JENKINS=0\nMAXIMUM_UNMOUNTING_ATTEMPTS=3\nSIGNATURE=""\nNOTARIZE=""\nEULA_RESOURCES_TEMPLATE_DATA=\'<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n    <key>LPic</key>\n    <array>\n        <dict>\n            <key>Attributes</key>\n            <string>0x0000</string>\n            <key>Data</key>\n            <data>\n            AAAAAgAAAAAAAAAAAAQAAA==\n            </data>\n            <key>ID</key>\n            <string>5000</string>\n            <key>Name</key>\n            <string></string>\n        </dict>\n    </array>\n    <key>STR#</key>\n    <array>\n        <dict>\n            <key>Attributes</key>\n            <string>0x0000</string>\n            <key>Data</key>\n            <data>\n            AAYNRW5nbGlzaCB0ZXN0MQVBZ3JlZQhEaXNhZ3JlZQVQcmludAdT\n            YXZlLi4ueklmIHlvdSBhZ3JlZSB3aXRoIHRoZSB0ZXJtcyBvZiB0\n            aGlzIGxpY2Vuc2UsIGNsaWNrICJBZ3JlZSIgdG8gYWNjZXNzIHRo\n            ZSBzb2Z0d2FyZS4gSWYgeW91IGRvIG5vdCBhZ3JlZSwgY2xpY2sg\n            IkRpc2FncmVlIi4=\n            </data>\n            <key>ID</key>\n            <string>5000</string>\n            <key>Name</key>\n            <string>English buttons</string>\n        </dict>\n        <dict>\n            <key>Attributes</key>\n            <string>0x0000</string>\n            <key>Data</key>\n            <data>\n            AAYHRW5nbGlzaAVBZ3JlZQhEaXNhZ3JlZQVQcmludAdTYXZlLi4u\n            e0lmIHlvdSBhZ3JlZSB3aXRoIHRoZSB0ZXJtcyBvZiB0aGlzIGxp\n            Y2Vuc2UsIHByZXNzICJBZ3JlZSIgdG8gaW5zdGFsbCB0aGUgc29m\n            dHdhcmUuIElmIHlvdSBkbyBub3QgYWdyZWUsIGNsaWNrICJEaXNh\n            Z3JlZSIu\n            </data>\n            <key>ID</key>\n            <string>5002</string>\n            <key>Name</key>\n            <string>English</string>\n        </dict>\n    </array>\n    <key>${EULA_FORMAT}</key>\n    <array>\n        <dict>\n            <key>Attributes</key>\n            <string>0x0000</string>\n            <key>Data</key>\n            <data>\n${EULA_DATA}\n            </data>\n            <key>ID</key>\n            <string>5000</string>\n            <key>Name</key>\n            <string>English</string>\n        </dict>\n    </array>\n    <key>TMPL</key>\n    <array>\n        <dict>\n            <key>Attributes</key>\n            <string>0x0000</string>\n            <key>Data</key>\n            <data>\n            E0RlZmF1bHQgTGFuZ3VhZ2UgSUREV1JEBUNvdW50T0NOVAQqKioq\n            TFNUQwtzeXMgbGFuZyBJRERXUkQebG9jYWwgcmVzIElEIChvZmZz\n            ZXQgZnJvbSA1MDAwRFdSRBAyLWJ5dGUgbGFuZ3VhZ2U/RFdSRAQq\n            KioqTFNURQ==\n            </data>\n            <key>ID</key>\n            <string>128</string>\n            <key>Name</key>\n            <string>LPic</string>\n        </dict>\n    </array>\n    <key>styl</key>\n    <array>\n        <dict>\n            <key>Attributes</key>\n            <string>0x0000</string>\n            <key>Data</key>\n            <data>\n            AAMAAAAAAAwACQAUAAAAAAAAAAAAAAAAACcADAAJABQBAAAAAAAA\n            AAAAAAAKgAMAAkAFAAAAAAAAAAAAAA=\n            </data>\n            <key>ID</key>\n            <string>5000</string>\n            <key>Name</key>\n            <string>English</string>\n        </dict>\n    </array>\n</dict>\n</plist>\'\nTEMPLATE_APPLESCRIPT_DATA=\'on run (volumeName)\n	tell application "Finder"\n		tell disk (volumeName as string)\n			open\n\n			set theXOrigin to WINX\n			set theYOrigin to WINY\n			set theWidth to WINW\n			set theHeight to WINH\n\n			set theBottomRightX to (theXOrigin + theWidth)\n			set theBottomRightY to (theYOrigin + theHeight)\n			set dsStore to "\\"" & "/Volumes/" & volumeName & "/" & ".DS_STORE\\""\n\n			tell container window\n				set current view to icon view\n				set toolbar visible to false\n				set statusbar visible to false\n				set the bounds to {theXOrigin, theYOrigin, theBottomRightX, theBottomRightY}\n				set statusbar visible to false\n				REPOSITION_HIDDEN_FILES_CLAUSE\n			end tell\n\n			set opts to the icon view options of container window\n			tell opts\n				set icon size to ICON_SIZE\n				set text size to TEXT_SIZE\n				set arrangement to not arranged\n			end tell\n			BACKGROUND_CLAUSE\n\n			-- Positioning\n			POSITION_CLAUSE\n\n			-- Hiding\n			HIDING_CLAUSE\n\n			-- Application and QL Link Clauses\n			APPLICATION_CLAUSE\n			QL_CLAUSE\n			close\n			open\n			-- Force saving of the size\n			delay 1\n\n			tell container window\n				set statusbar visible to false\n				set the bounds to {theXOrigin, theYOrigin, theBottomRightX - 10, theBottomRightY - 10}\n			end tell\n		end tell\n\n		delay 1\n\n		tell disk (volumeName as string)\n			tell container window\n				set statusbar visible to false\n				set the bounds to {theXOrigin, theYOrigin, theBottomRightX, theBottomRightY}\n			end tell\n		end tell\n\n		--give the finder some time to write the .DS_Store file\n		delay 3\n\n		set waitTime to 0\n		set ejectMe to false\n		repeat while ejectMe is false\n			delay 1\n			set waitTime to waitTime + 1\n			\n			if (do shell script "[ -f " & dsStore & " ]; echo $?") = "0" then set ejectMe to true\n		end repeat\n		log "waited " & waitTime & " seconds for .DS_STORE to be created."\n	end tell\nend run\n\'\nfunction pure_version() {\n	echo "$CDMG_VERSION"\n}\n\nfunction hdiutil_detach_retry() {\n	# Unmount\n	unmounting_attempts=0\n	until\n		echo "Unmounting disk image..."\n		(( unmounting_attempts++ ))\n		hdiutil detach "$1"\n		exit_code=$?\n		(( exit_code ==  0 )) && break            # nothing goes wrong\n		(( exit_code != 16 )) && exit $exit_code  # exit with the original exit code\n		# The above statement returns 1 if test failed (exit_code == 16).\n		#   It can make the code in the {do... done} block to be executed\n	do\n		(( unmounting_attempts == MAXIMUM_UNMOUNTING_ATTEMPTS )) && exit 16  # patience exhausted, exit with code EBUSY\n		echo "Wait a moment..."\n		sleep $(( 1 * (2 ** unmounting_attempts) ))\n	done\n	unset unmounting_attempts\n}\n\nfunction version() {\n	echo "create-dmg $(pure_version)"\n}\n\n# factors can cause interstitial disk images to contain more than a single\n# partition - expand the hunt for the temporary disk image by checking for\n# the path of the volume, versus assuming its the first result (as in pr/152).\nfunction find_mount_dir() {\n	local dev_name="${1}"\n\n	>&2 echo "Searching for mounted interstitial disk image using ${dev_name}... "\n	# enumerate up to 9 partitions\n	for i in {1..9}; do\n		# attempt to find the partition\n		local found_dir\n		found_dir=$(hdiutil info | grep -E --color=never "${dev_name}" | head -${i} | awk \'{print $3}\')\n		if [[ -n "${found_dir}" ]]; then\n				echo "${found_dir}"\n				return 0\n		fi\n	done\n}\n\n# Argument parsing\n\nwhile [[ "${1:0:1}" = "-" ]]; do\n	case $1 in\n		--volname)\n			VOLUME_NAME="$2"\n			shift; shift;;\n		--volicon)\n			VOLUME_ICON_FILE="$2"\n			shift; shift;;\n		--background)\n			BACKGROUND_FILE="$2"\n			BACKGROUND_FILE_NAME="$(basename "$BACKGROUND_FILE")"\n			BACKGROUND_CLAUSE="set background picture of opts to file \\".background:$BACKGROUND_FILE_NAME\\""\n			REPOSITION_HIDDEN_FILES_CLAUSE="set position of every item to {theBottomRightX + 100, 100}"\n			shift; shift;;\n		--icon-size)\n			ICON_SIZE="$2"\n			shift; shift;;\n		--text-size)\n			TEXT_SIZE="$2"\n			shift; shift;;\n		--window-pos)\n			WINX=$2; WINY=$3\n			shift; shift; shift;;\n		--window-size)\n			WINW=$2; WINH=$3\n			shift; shift; shift;;\n		--icon)\n			POSITION_CLAUSE="${POSITION_CLAUSE}set position of item \\"$2\\" to {$3, $4}\n			"\n			shift; shift; shift; shift;;\n		--hide-extension)\n			HIDING_CLAUSE="${HIDING_CLAUSE}set the extension hidden of item \\"$2\\" to true\n			"\n			shift; shift;;\n		--version)\n			version; exit 0;;\n		--pure-version)\n			pure_version; exit 0;;\n		--ql-drop-link)\n			QL_LINK=$2\n			QL_CLAUSE="set position of item \\"QuickLook\\" to {$2, $3}\n			"\n			shift; shift; shift;;\n		--app-drop-link)\n			APPLICATION_LINK=$2\n			APPLICATION_CLAUSE="set position of item \\"Applications\\" to {$2, $3}\n			"\n			shift; shift; shift;;\n		--eula)\n			EULA_RSRC=$2\n			shift; shift;;\n		--no-internet-enable)\n			NOINTERNET=1\n			shift;;\n		--format)\n			FORMAT="$2"\n			shift; shift;;\n		--filesystem)\n			FILESYSTEM="$2"\n			shift; shift;;\n		--encrypt)\n			ENABLE_ENCRYPTION=1\n			AESBITS=256\n			shift;;\n		--encrypt-aes128)\n			ENABLE_ENCRYPTION=1\n			AESBITS=128\n			shift;;\n		--add-file | --add-folder)\n			ADD_FILE_TARGETS+=("$2")\n			ADD_FILE_SOURCES+=("$3")\n			POSITION_CLAUSE="${POSITION_CLAUSE}\n			set position of item \\"$2\\" to {$4, $5}\n			"\n			shift; shift; shift; shift; shift;;\n		--disk-image-size)\n			DISK_IMAGE_SIZE="$2"\n			shift; shift;;\n		--hdiutil-verbose)\n			HDIUTIL_VERBOSITY=\'-verbose\'\n			shift;;\n		--hdiutil-quiet)\n			HDIUTIL_VERBOSITY=\'-quiet\'\n			shift;;\n		--codesign)\n			SIGNATURE="$2"\n			shift; shift;;\n		--notarize)\n			NOTARIZE="$2"\n			shift; shift;;\n		--sandbox-safe)\n			SANDBOX_SAFE=1\n			shift;;\n		--bless)\n			BLESS=1\n			shift;;\n		--rez)\n			echo "REZ is no more directly used. You can remove the --rez argument."\n			shift; shift;;\n		--skip-jenkins)\n			SKIP_JENKINS=1\n			shift;;\n		-*)\n			echo "Unknown option: $1. Run \'create-dmg --help\' for help."\n			exit 1;;\n	esac\n	case $FORMAT in\n		UDZO)\n			IMAGEKEY="-imagekey zlib-level=9";;\n		UDBZ)\n			IMAGEKEY="-imagekey bzip2-level=9";;\n		ULFO)\n			;;\n		ULMO)\n			;;\n		*)\n			echo >&2 "Unknown disk image format: $FORMAT"\n			exit 1;;\n	esac\ndone\n\nif [[ -z "$2" ]]; then\n	echo "Not enough arguments. Run \'create-dmg --help\' for help."\n	exit 1\nfi\n\nDMG_PATH="$1"\nSRC_FOLDER="$(cd "$2" > /dev/null; pwd)"\n\n# Argument validation checks\n\nif [[ "${DMG_PATH: -4}" != ".dmg" ]]; then\n	echo "Output file name must end with a .dmg extension. Run \'create-dmg --help\' for help."\n	exit 1\nfi\n\nif [[ "${FILESYSTEM}" != "HFS+" ]] && [[ "${FILESYSTEM}" != "APFS" ]]; then\n	echo "Unknown disk image filesystem: ${FILESYSTEM}. Run \'create-dmg --help\' for help."\n	exit 1\nfi\n\nif [[ "${FILESYSTEM}" == "APFS" ]] && [[ ${SANDBOX_SAFE} -eq 1 ]]; then\n	echo "Creating an APFS disk image that is sandbox safe is not supported."\n	exit 1\nfi\n\n# Main script logic\n\nSCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"\nDMG_DIRNAME="$(dirname "$DMG_PATH")"\nDMG_DIR="$(cd "$DMG_DIRNAME" > /dev/null; pwd)"\nDMG_NAME="$(basename "$DMG_PATH")"\nDMG_TEMP_NAME="$DMG_DIR/rw.$$.${DMG_NAME}"\n\n# Detect where we\'re running from\n\n# sentinel_file="$SCRIPT_DIR/.this-is-the-create-dmg-repo"\n# if [[ -f "$sentinel_file" ]]; then\n# 	# We\'re running from inside a repo\n# 	CDMG_SUPPORT_DIR="$SCRIPT_DIR/support"\n# else\n# 	# We\'re running inside an installed location\n# 	bin_dir="$SCRIPT_DIR"\n# 	prefix_dir=$(dirname "$bin_dir")\n# 	CDMG_SUPPORT_DIR="$prefix_dir/build-dmg/support"\n# fi\n\n# if [[ -z "$VOLUME_NAME" ]]; then\n# 	VOLUME_NAME="$(basename "$DMG_PATH" .dmg)"\n# fi\n\n# if [[ ! -d "$CDMG_SUPPORT_DIR" ]]; then\n# 	echo >&2 "Cannot find support/ directory: expected at: $CDMG_SUPPORT_DIR"\n# 	exit 1\n# fi\n\nif [[ -f "$SRC_FOLDER/.DS_Store" ]]; then\n	echo "Deleting .DS_Store found in source folder"\n	rm "$SRC_FOLDER/.DS_Store"\nfi\n\n# Create the image\necho "Creating disk image..."\nif [[ -f "${DMG_TEMP_NAME}" ]]; then\n	rm -f "${DMG_TEMP_NAME}"\nfi\n\n# Use Megabytes since hdiutil fails with very large byte numbers\nfunction blocks_to_megabytes() {\n	# Add 1 extra MB, since there\'s no decimal retention here\n	MB_SIZE=$((($1 * 512 / 1000 / 1000) + 1))\n	echo $MB_SIZE\n}\n\nfunction get_size() {\n	# Get block size in disk\n	if [[ $OS_MAJOR_VERSION -ge 12 ]]; then\n		bytes_size=$(du -B 512 -s "$1")\n	else\n		bytes_size=$(du -s "$1")\n	fi\n	bytes_size=$(echo $bytes_size | sed -e \'s/	.*//g\')\n	echo $(blocks_to_megabytes $bytes_size)\n}\n\n# Create the DMG with the specified size or the hdiutil estimation\nCUSTOM_SIZE=\'\'\nif [[ -n "$DISK_IMAGE_SIZE" ]]; then\n	CUSTOM_SIZE="-size ${DISK_IMAGE_SIZE}m"\nfi\n\nif [[ $SANDBOX_SAFE -eq 0 ]]; then\n	if [[ "$FILESYSTEM" == "APFS" ]]; then\n		FILESYSTEM_ARGUMENTS=""\n	else\n		FILESYSTEM_ARGUMENTS="-c c=64,a=16,e=16"\n	fi\n	hdiutil create ${HDIUTIL_VERBOSITY} -srcfolder "$SRC_FOLDER" -volname "${VOLUME_NAME}" \\\n		-fs "${FILESYSTEM}" -fsargs "${FILESYSTEM_ARGUMENTS}" -format UDRW ${CUSTOM_SIZE} "${DMG_TEMP_NAME}"\nelse\n	hdiutil makehybrid ${HDIUTIL_VERBOSITY} -default-volume-name "${VOLUME_NAME}" -hfs -o "${DMG_TEMP_NAME}" "$SRC_FOLDER"\n	hdiutil convert -format UDRW -ov -o "${DMG_TEMP_NAME}" "${DMG_TEMP_NAME}"\n	DISK_IMAGE_SIZE_CUSTOM=$DISK_IMAGE_SIZE\nfi\n\n# Get the created DMG actual size\nDISK_IMAGE_SIZE=$(get_size "${DMG_TEMP_NAME}")\n\n# Use the custom size if bigger\nif [[ $SANDBOX_SAFE -eq 1 ]] && [[ ! -z "$DISK_IMAGE_SIZE_CUSTOM" ]] && [[ $DISK_IMAGE_SIZE_CUSTOM -gt $DISK_IMAGE_SIZE ]]; then\n	DISK_IMAGE_SIZE=$DISK_IMAGE_SIZE_CUSTOM\nfi\n\n# Estimate the additional sources size\nif [[ -n "$ADD_FILE_SOURCES" ]]; then\n	for i in "${!ADD_FILE_SOURCES[@]}"; do\n		SOURCE_SIZE=$(get_size "${ADD_FILE_SOURCES[$i]}")\n		DISK_IMAGE_SIZE=$(expr $DISK_IMAGE_SIZE + $SOURCE_SIZE)\n	done\nfi\n\n# Add extra space for additional resources\nDISK_IMAGE_SIZE=$(expr $DISK_IMAGE_SIZE + 20)\n\n# Make sure target image size is within limits\nMIN_DISK_IMAGE_SIZE=$(hdiutil resize -limits "${DMG_TEMP_NAME}" | awk \'NR=1{print int($1/2048+1)}\')\nif [ $MIN_DISK_IMAGE_SIZE -gt $DISK_IMAGE_SIZE ]; then\n       DISK_IMAGE_SIZE=$MIN_DISK_IMAGE_SIZE\nfi\n\n# Resize the image for the extra stuff\nhdiutil resize ${HDIUTIL_VERBOSITY} -size ${DISK_IMAGE_SIZE}m "${DMG_TEMP_NAME}"\n\n# Mount the new DMG\n\necho "Mounting disk image..."\n\nMOUNT_RANDOM_PATH="/Volumes"\nif [[ $SANDBOX_SAFE -eq 1 ]]; then\n	MOUNT_RANDOM_PATH="/tmp"\nfi\nDEV_NAME=$(hdiutil attach -mountrandom ${MOUNT_RANDOM_PATH} -readwrite -noverify -noautoopen -nobrowse "${DMG_TEMP_NAME}" | grep -E --color=never \'^/dev/\' | sed 1q | awk \'{print $1}\')\necho "Device name:     $DEV_NAME"\nMOUNT_DIR=$(find_mount_dir "${DEV_NAME}s")\n\nif [[ -z "${MOUNT_DIR}" ]]; then\n  >&2 echo "ERROR: unable to proceed with final disk image creation because the interstitial disk image was not found."\n  >&2 echo "The interstitial disk image will likely be mounted and will need to be cleaned up manually."\n  exit 1\nfi\n\necho "Mount dir:       $MOUNT_DIR"\n\nif [[ -n "$BACKGROUND_FILE" ]]; then\n	echo "Copying background file \'$BACKGROUND_FILE\'..."\n	[[ -d "$MOUNT_DIR/.background" ]] || mkdir "$MOUNT_DIR/.background"\n	cp "$BACKGROUND_FILE" "$MOUNT_DIR/.background/$BACKGROUND_FILE_NAME"\nfi\n\nif [[ -n "$APPLICATION_LINK" ]]; then\n	echo "Making link to Applications dir..."\n	echo $MOUNT_DIR\n	ln -s /Applications "$MOUNT_DIR/Applications"\nfi\n\nif [[ -n "$QL_LINK" ]]; then\n	echo "Making link to QuickLook install dir..."\n	echo $MOUNT_DIR\n	ln -s "/Library/QuickLook" "$MOUNT_DIR/QuickLook"\nfi\n\nif [[ -n "$VOLUME_ICON_FILE" ]]; then\n	echo "Copying volume icon file \'$VOLUME_ICON_FILE\'..."\n	cp "$VOLUME_ICON_FILE" "$MOUNT_DIR/.VolumeIcon.icns"\n	SetFile -c icnC "$MOUNT_DIR/.VolumeIcon.icns"\nfi\n\nif [[ -n "$ADD_FILE_SOURCES" ]]; then\n	echo "Copying custom files..."\n	for i in "${!ADD_FILE_SOURCES[@]}"; do\n		echo "${ADD_FILE_SOURCES[$i]}"\n		cp -a "${ADD_FILE_SOURCES[$i]}" "$MOUNT_DIR/${ADD_FILE_TARGETS[$i]}"\n	done\nfi\n\nVOLUME_NAME=$(basename $MOUNT_DIR)\n\n# Run AppleScript to do all the Finder cosmetic stuff\nAPPLESCRIPT_FILE=$(mktemp -t createdmg.tmp.XXXXXXXXXX)\nif [[ $SANDBOX_SAFE -eq 1 ]]; then\n	echo "Skipping Finder-prettifying AppleScript because we are in Sandbox..."\nelse\n	if [[ $SKIP_JENKINS -eq 0 ]]; then\n	\n		echo "$TEMPLATE_APPLESCRIPT_DATA" \\\n			| sed -e "s/WINX/$WINX/g" -e "s/WINY/$WINY/g" -e "s/WINW/$WINW/g" \\\n					-e "s/WINH/$WINH/g" -e "s/BACKGROUND_CLAUSE/$BACKGROUND_CLAUSE/g" \\\n					-e "s/REPOSITION_HIDDEN_FILES_CLAUSE/$REPOSITION_HIDDEN_FILES_CLAUSE/g" \\\n					-e "s/ICON_SIZE/$ICON_SIZE/g" -e "s/TEXT_SIZE/$TEXT_SIZE/g" \\\n			| perl -pe "s/POSITION_CLAUSE/$POSITION_CLAUSE/g" \\\n			| perl -pe "s/QL_CLAUSE/$QL_CLAUSE/g" \\\n			| perl -pe "s/APPLICATION_CLAUSE/$APPLICATION_CLAUSE/g" \\\n			| perl -pe "s/HIDING_CLAUSE/$HIDING_CLAUSE/" \\\n			> "$APPLESCRIPT_FILE"\n		# old: \n		# cat "$CDMG_SUPPORT_DIR/template.applescript" \\\n		# 	| sed -e "s/WINX/$WINX/g" -e "s/WINY/$WINY/g" -e "s/WINW/$WINW/g" \\\n		# 			-e "s/WINH/$WINH/g" -e "s/BACKGROUND_CLAUSE/$BACKGROUND_CLAUSE/g" \\\n		# 			-e "s/REPOSITION_HIDDEN_FILES_CLAUSE/$REPOSITION_HIDDEN_FILES_CLAUSE/g" \\\n		# 			-e "s/ICON_SIZE/$ICON_SIZE/g" -e "s/TEXT_SIZE/$TEXT_SIZE/g" \\\n		# 	| perl -pe "s/POSITION_CLAUSE/$POSITION_CLAUSE/g" \\\n		# 	| perl -pe "s/QL_CLAUSE/$QL_CLAUSE/g" \\\n		# 	| perl -pe "s/APPLICATION_CLAUSE/$APPLICATION_CLAUSE/g" \\\n		# 	| perl -pe "s/HIDING_CLAUSE/$HIDING_CLAUSE/" \\\n		# 	> "$APPLESCRIPT_FILE"\n		sleep 2 # pause to workaround occasional "Cant get disk" (-1728) issues  \n		echo "Running AppleScript to make Finder stuff pretty: /usr/bin/osascript \\"${APPLESCRIPT_FILE}\\" \\"${VOLUME_NAME}\\""\n		if /usr/bin/osascript "${APPLESCRIPT_FILE}" "${VOLUME_NAME}"; then\n			# Okay, we\'re cool\n			# true\n			echo\n		else\n			echo >&2 "Failed running AppleScript"\n			hdiutil_detach_retry "${DEV_NAME}"\n			exit 64\n		fi\n		echo "Done running the AppleScript..."\n		sleep 4\n		rm "$APPLESCRIPT_FILE"\n	fi\nfi\n\n# Make sure it\'s not world writeable\necho "Fixing permissions..."\nchmod -Rf go-w "${MOUNT_DIR}" &> /dev/null || true\necho "Done fixing permissions"\n\n# Make the top window open itself on mount:\nif [[ $BLESS -eq 1 && $SANDBOX_SAFE -eq 0 ]]; then\n	echo "Blessing started"\n	if [ $(uname -m) == "arm64" ]; then\n		bless --folder "${MOUNT_DIR}"\n	else\n		bless --folder "${MOUNT_DIR}" --openfolder "${MOUNT_DIR}"\n	fi\n	echo "Blessing finished"\nelse\n	echo "Skipping blessing on sandbox"\nfi\n\nif [[ -n "$VOLUME_ICON_FILE" ]]; then\n	# Tell the volume that it has a special file attribute\n	SetFile -a C "$MOUNT_DIR"\nfi\n\n# Delete unnecessary file system events log if possible\necho "Deleting .fseventsd"\nrm -rf "${MOUNT_DIR}/.fseventsd" || true\n\nhdiutil_detach_retry "${DEV_NAME}"\n\n# Compress image and optionally encrypt\nif [[ $ENABLE_ENCRYPTION -eq 0 ]]; then\n	echo "Compressing disk image..."\n	hdiutil convert ${HDIUTIL_VERBOSITY} "${DMG_TEMP_NAME}" -format ${FORMAT} ${IMAGEKEY} -o "${DMG_DIR}/${DMG_NAME}"\nelse\n	echo "Compressing and encrypting disk image..."\n	echo "NOTE: hdiutil will only prompt a single time for a password - ensure entry is correct."\n	hdiutil convert ${HDIUTIL_VERBOSITY} "${DMG_TEMP_NAME}" -format ${FORMAT} ${IMAGEKEY} -encryption AES-${AESBITS} -stdinpass -o "${DMG_DIR}/${DMG_NAME}"\nfi\nrm -f "${DMG_TEMP_NAME}"\n\n# Adding EULA resources\nif [[ -n "${EULA_RSRC}" && "${EULA_RSRC}" != "-null-" ]]; then\n	echo "Adding EULA resources..."\n	#\n	# Use udifrez instead flatten/rez/unflatten\n	# https://github.com/create-dmg/create-dmg/issues/109\n	#\n	# Based on a thread from dawn2dusk & peterguy\n	# https://developer.apple.com/forums/thread/668084\n	#\n	EULA_RESOURCES_FILE=$(mktemp -t createdmg.tmp.XXXXXXXXXX)\n	EULA_FORMAT=$(file -b ${EULA_RSRC})\n	if [[ ${EULA_FORMAT} == \'Rich Text Format data\'* ]] ; then\n		EULA_FORMAT=\'RTF \'\n	else\n		EULA_FORMAT=\'TEXT\'\n	fi\n	# Encode the EULA to base64\n	# Replace \'openssl base64\' with \'base64\' if Mac OS X 10.6 support is no more needed\n	# EULA_DATA="$(base64 -b 52 "${EULA_RSRC}" | sed s$\'/^\\(.*\\)$/\\t\\t\\t\\\\1/\')"\n	EULA_DATA="$(openssl base64 -in "${EULA_RSRC}" | tr -d \'\\n\' | awk \'{gsub(/.{52}/,"&\\n")}1\' | sed s$\'/^\\(.*\\)$/\\t\\t\\t\\\\1/\')"\n	# Fill the template with the custom EULA contents\n	echo "$EULA_RESOURCES_TEMPLATE_DATA" > "$EULA_RESOURCES_FILE"\n	# old:\n	# eval "cat > \\"${EULA_RESOURCES_FILE}\\" <<EOF                                                                                                                  \n	# $(<${CDMG_SUPPORT_DIR}/eula-resources-template.xml)\n	# EOF\n	# "\n\n	# Apply the resources\n	hdiutil udifrez -xml "${EULA_RESOURCES_FILE}" \'\' -quiet "${DMG_DIR}/${DMG_NAME}" || {\n		echo "Failed to add the EULA license"\n		exit 1\n	}\n	echo "Successfully added the EULA license"\nfi\n\n# Enable "internet", whatever that is\nif [[ ! -z "${NOINTERNET}" && "${NOINTERNET}" == 1 ]]; then\n	echo "Not setting \'internet-enable\' on the dmg, per caller request"\nelse\n	# Check if hdiutil supports internet-enable\n	# Support was removed in macOS 10.15. See https://github.com/andreyvit/create-dmg/issues/76\n	if hdiutil internet-enable -help >/dev/null 2>/dev/null; then\n		hdiutil internet-enable -yes "${DMG_DIR}/${DMG_NAME}"\n	else\n		echo "hdiutil does not support internet-enable. Note it was removed in macOS 10.15."\n	fi\nfi\n\nif [[ -n "${SIGNATURE}" && "${SIGNATURE}" != "-null-" ]]; then\n	echo "Codesign started"	\n	codesign -s "${SIGNATURE}" "${DMG_DIR}/${DMG_NAME}"\n	dmgsignaturecheck="$(codesign --verify --deep --verbose=2 --strict "${DMG_DIR}/${DMG_NAME}" 2>&1 >/dev/null)"\n	if [ $? -eq 0 ]; then\n		echo "The disk image is now codesigned"\n	else\n		echo "The signature seems invalid${NC}"\n		exit 1\n	fi\nfi\n\nif [[ -n "${NOTARIZE}" && "${NOTARIZE}" != "-null-" ]]; then\n	echo "Notarization started"	\n	xcrun notarytool submit "${DMG_DIR}/${DMG_NAME}" --keychain-profile "${NOTARIZE}" --wait\n	echo "Stapling the notarization ticket"\n	staple="$(xcrun stapler staple "${DMG_DIR}/${DMG_NAME}")"\n	if [ $? -eq 0 ]; then\n		echo "The disk image is now notarized"\n	else\n		echo "$staple"\n		echo "The notarization failed with error $?"\n		exit 1\n	fi\nfi\n\n# All done!\necho "Disk image done"\nexit 0\n'
        };
        await this.fs.writeFile(DMG_SCRIPT.path, DMG_SCRIPT.content);
        const DMG_CMD = await this.command_createDMG(DMG_SCRIPT.path, DMG_CMD_PARAMS);
        params.log.verbose({
          title: "DMG params",
          value: DMG_CMD_PARAMS
        });
        await this.childProcess.execute({
          cmd: DMG_CMD,
          ...logFuncts
        });
        SAFARI_OOTPUT = this.fs.getAbsolutePath(SAFARI_DMG_OUTPUT);
      } else if (type === appTypes.macos && params.onlyXcodeProject) {
        SAFARI_OOTPUT = SAFARI_XCODEPROJECT_DIR_PATH;
      } else {
        SAFARI_OOTPUT = this.fs.getAbsolutePath(SAFARI_APP_BUILD_RELEASE_PATH);
      }
      params.log.changeText("ð Creating compress file");
      const compressParams = {
        inputPath: SAFARI_OOTPUT,
        outputPath: this.fs.getAbsolutePath(params.output),
        outputName: params.filename,
        format: params.compress
      };
      params.log.verbose({
        title: "Compress params",
        values: compressParams
      });
      await this.fs.compress(compressParams);
      const compressFile = this.fs.getCompressOutputPath(params.output, params.filename, params.compress);
      params.log.succeed(`Successful building in: ${compressFile}`);
    } catch (e) {
      throw e;
    } finally {
      await this.fs.removeDirIfExist(SAFARI_TEMP_PATH);
    }
  }
  async buildSafariBrowserWithProps(props, values) {
    await this.buildBrowserConstructor({
      props: {
        inputPath: values.input,
        values,
        ...props
      },
      cb: async (params) => {
        if (!this.isMacos()) throw Error("You must be on macOS to build a safari extension");
        await this.buildDmg(props, params, appTypes.macos);
      },
      onError: ({ log, error }) => {
        log.failed(error);
      }
    });
  }
  async buildSafariIosBrowserWithProps(props, values) {
    await this.buildBrowserConstructor({
      props: {
        inputPath: values.input,
        values,
        ...props
      },
      cb: async (params) => {
        if (!this.isMacos()) throw Error("You must be on macOS to build a safari extension");
        await this.buildDmg(props, params, appTypes.ios);
      },
      onError: ({ log, error }) => {
        log.failed(error);
      }
    });
  }
}
class BuildSafariMV2Core extends BuildSafariSharedCore {
  props = {
    name: browserTypes.safariMv2,
    target: extTypes.chromium,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildSafariBrowserWithProps(this.props, values);
  }
}
class BuildSafariCore extends BuildSafariSharedCore {
  props = {
    name: browserTypes.safari,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    const buildSafariBrowserPromise = this.buildSafariBrowserWithProps(this.props, values);
    const coreMv2Promise = values.inputMv2 ? new BuildSafariMV2Core().create({ ...values, input: values.inputMv2 }) : Promise.resolve();
    await Promise.all([buildSafariBrowserPromise, coreMv2Promise]);
  }
}
const core$6 = new BuildSafariCore();
const coreMv2$1 = new BuildSafariMV2Core();
const safari = {
  props: core$6.props,
  /**
   * Build Safari extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/safari
   */
  build: core$6.create.bind(core$6),
  mv2: {
    /**
     * Build Safari extension (with chromium manifest 2).
     *
     * @returns {Promise<void>}                    
     * @see https://bepp.pigeonposse.com/guide/build/safari
     */
    build: coreMv2$1.create.bind(coreMv2$1),
    props: coreMv2$1.props
  }
};
class BuildBraveCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.brave,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
const core$5 = new BuildBraveCore();
const brave = {
  props: core$5.props,
  /**
   * Build Brave extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/brave
   */
  build: core$5.create.bind(core$5)
};
class BuildCustomCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.custom,
    target: extTypes.all,
    man: manVersions.none
  };
  async create(values) {
    this.props.name = values.browserName || this.props.name;
    await this.buildBrowserWithProps(this.props, values);
  }
}
const core$4 = new BuildCustomCore();
const custom = {
  props: core$4.props,
  /**
   * Build Custom extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/custom
   */
  build: core$4.create.bind(core$4)
};
class BuildOperaGXCore extends BuildBrowserSharedCore {
  // necessary to obtain it outside of class
  props = {
    name: browserTypes.operagx,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
const core$3 = new BuildOperaGXCore();
const operaGx = {
  props: core$3.props,
  /**
   * Build Oera GX extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/opera-gx
   */
  build: core$3.create.bind(core$3)
};
class BuildOperaCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.opera,
    target: extTypes.chromium,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
const core$2 = new BuildOperaCore();
const opera = {
  props: core$2.props,
  /**
   * Build Opera extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/opera
   */
  build: core$2.create.bind(core$2)
};
class BuildYandexMV2Core extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.yandexMv2,
    target: extTypes.chromium,
    man: manVersions[2]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
  }
}
class BuildYandexCore extends BuildBrowserSharedCore {
  props = {
    name: browserTypes.yandex,
    target: extTypes.chromium,
    man: manVersions[3]
  };
  async create(values) {
    await this.buildBrowserWithProps(this.props, values);
    if (values.inputMv2) {
      const coreMv22 = new BuildYandexMV2Core();
      await coreMv22.create({ ...values, input: values.inputMv2 });
    }
  }
}
const core$1 = new BuildYandexCore();
const coreMv2 = new BuildYandexMV2Core();
const yandex = {
  props: core$1.props,
  /**
   * Build Yandex extension.
   *
   * @returns {Promise<void>}                    
   * @see https://bepp.pigeonposse.com/guide/build/yandex
   */
  build: core$1.create.bind(core$1),
  mv2: {
    /**
     * Build Yandex extension (Manifest 2).
     *
     * @returns {Promise<void>}                    
     * @see https://bepp.pigeonposse.com/guide/build/yandex
     */
    build: coreMv2.create.bind(coreMv2),
    props: coreMv2.props
  }
};
const allBrowsers = {
  [browserTypes.safari]: { ...safari, mv2: void 0 },
  [browserTypes.safariMv2]: safari.mv2,
  // [browserTypes.safariIos]: safariIos,
  [browserTypes.chrome]: { ...chrome, mv2: void 0 },
  [browserTypes.chromeMv2]: chrome.mv2,
  [browserTypes.firefox]: { ...firefox, mv2: void 0 },
  [browserTypes.firefoxMv2]: firefox.mv2,
  [browserTypes.chromium]: { ...chromium, mv2: void 0 },
  [browserTypes.chromiumMv2]: chromium.mv2,
  [browserTypes.edge]: { ...edge, mv2: void 0 },
  [browserTypes.edgeMv2]: edge.mv2,
  [browserTypes.yandex]: { ...yandex, mv2: void 0 },
  [browserTypes.yandexMv2]: yandex.mv2,
  [browserTypes.brave]: brave,
  [browserTypes.opera]: opera,
  [browserTypes.operagx]: operaGx,
  [browserTypes.custom]: custom
};
const buildBrowser = async (type, args) => {
  if (!(type in allBrowsers)) throw new Error(`Invalid browser type "${type}"`);
  await allBrowsers[type].build(args);
};
const buildAllBrowsers = async (args) => {
  for (const key in args) {
    if (Object.prototype.hasOwnProperty.call(args, key)) {
      await buildBrowser(key, args[key]);
    }
  }
};
class BuildConfigCore extends BuildSharedCore {
  schema = schema.definitions.BuildConfigSchema;
  defaultConfigPaths = [
    this.id + ".config.json",
    this.id + ".config.yaml",
    this.id + ".config.yml",
    this.id + ".config.toml"
  ];
  defaultParams = {
    ...this.globalDefaultParams,
    config: void 0
  };
  async create(v) {
    await this.setFunctionConstructor({
      name: "Build",
      defaultValues: this.defaultParams,
      values: v,
      cb: async ({ log, values }) => {
        log.start("Staring...");
        let configPath = void 0;
        let configData;
        if ("data" in values && typeof values.config === "object") configData = values.config;
        else {
          if (!values.config || typeof values.config !== "string") {
            log.changeText("Searching configuration file automatically...");
            for (let index = 0; index < this.defaultConfigPaths.length; index++) {
              const file = resolve$1(this.defaultConfigPaths[index]);
              const exists = await this.fs.existsFile(file);
              if (exists) {
                configPath = file;
                break;
              }
            }
            if (!configPath) throw new Error(`There is no supported configuration file. Supported files: ${this.defaultConfigPaths.join(" or ")}`);
          } else {
            configPath = values.config;
          }
          log.changeText("Getting data from file: " + configPath);
          configData = await this.fs.getDataFromFile(configPath);
        }
        log.verbose({
          title: "Config data:",
          value: configData
        });
        await this.type.object.validateWithSchema(
          configData,
          this.schema,
          this.log.verbose
        );
        const cores = allBrowsers;
        let sharedParams = this.defaultParams;
        if (configData.shared) {
          sharedParams = { ...sharedParams, ...configData.shared };
        }
        if (!configData.build) throw Error('Error in config file: No "build" key found.');
        const buildStrings = [];
        const promises = [];
        for (let index = 0; index < configData.build.length; index++) {
          const element = configData.build[index];
          if (element && element.type && cores[element.type]) {
            buildStrings.push(element.type);
            const promise = (async () => {
              const props = cores[element.type].props;
              const input = (() => {
                if (props.target === extTypes.chromium) {
                  if (props.man === manVersions[3]) {
                    return element.input || sharedParams.input[manTypes.chromium];
                  } else if (props.man === manVersions[2]) {
                    return element.input || sharedParams.input[manTypes.chromiumMv2];
                  }
                  return element.input;
                } else if (props.target === extTypes.firefox) {
                  if (props.man === manVersions[3]) {
                    return element.input || sharedParams.input[manTypes.firefox];
                  } else if (props.man === manVersions[2]) {
                    return element.input || sharedParams.input[manTypes.firefoxMv2];
                  }
                  return element.input;
                }
                return element.input;
              })();
              const shared = sharedParams.input ? (({ input: input2, ...rest }) => rest)(sharedParams) : sharedParams;
              const data = {
                ...shared,
                ...(({ type, ...rest }) => rest)(element),
                input,
                // time: false, // always false because there are problems with spinner
                verbose: this.log.verbose
              };
              log.verbose({
                title: `data for extension ${element.type}`,
                value: data
              });
              await cores[element.type].build(data);
            })();
            promises.push(promise);
          }
        }
        log.changeText(`Building for [${buildStrings.toString()}]`);
        await Promise.all(promises);
        log.succeed(`Built extensions for [${buildStrings.toString()}]`);
      }
    });
  }
}
const core = new BuildConfigCore();
const buildConfig = async (values) => await core.create(values);
export {
  firefox as A,
  BuildConfigCore as B,
  opera as C,
  operaGx as D,
  safari as E,
  yandex as F,
  init as G,
  InitCore as I,
  Logger as L,
  extTypes as a,
  BuildBrowserSharedCore as b,
  compressTypes as c,
  description as d,
  extra as e,
  BuildChromiumCore as f,
  BuildEdgeCore as g,
  BuildBraveCore as h,
  BuildOperaCore as i,
  BuildOperaGXCore as j,
  BuildChromeCore as k,
  BuildFirefoxCore as l,
  BuildCustomCore as m,
  name as n,
  BuildYandexCore as o,
  BuildSafariCore as p,
  allBrowsers as q,
  brave as r,
  buildAllBrowsers as s,
  buildBrowser as t,
  buildConfig as u,
  version as v,
  chrome as w,
  chromium as x,
  custom as y,
  edge as z
};
